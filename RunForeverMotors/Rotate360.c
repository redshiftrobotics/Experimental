#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motor1,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#define USE_I2C

//#ifdef USE_I2C

//#include "../Libraries/I2C.h"
//#pragma config(Sensor, S1,     ,               sensorI2CCustom)
////*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#endif
//#ifndef USE_I2C

//#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
//#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
//#pragma config(Motor,  mtr_S1_C1_1,     motor1,        tmotorTetrix, openLoop)
//#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#endif

const int encAndyMark = -1120;
const int encTetrix = -1440;

const int speed = 10;

task main()
{
	clearDebugStream();
#ifdef USE_I2C
	// make sure to reset the encoder position by hard-resetting the motor controller

	I2C_SetEncoderPosition(S1, 1, 1, encAndyMark, speed);
	for (int i = 0; i <= 500; i++)
	{
		Sleep(1);
		writeDebugStreamLine("%i", I2C_GetEncoderPosition(S1, 1, 1));
	}
#else
		const int turns = 6;
		nMotorEncoder[motor1] = 0;

		while(nMotorEncoder[motor1] > encTetrix*turns)
		{
			motor[motor1] = speed;
			writeDebugStreamLine("%i, %i, %i", nMotorEncoder[motor1], nMotorEncoder[motorE], nMotorEncoder[motorE]-(-encAndyMark*turns));
		}

		motor[motor1] = 0;
#endif

}
